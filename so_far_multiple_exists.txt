struct t_exists{
 char* id;
   int index_reg;
   int array_size;
} exists[] = {NULL, 0, 0};

int exists_size = 1;
int quantifier_cursor = 1;


======================

%type <list> identifier_list

======================

identifier_list  : identifier_list COMMA IDENTIFIER
                  {  /* add the new identifier to the list of identifiers */
                    exists_size++;
                     $$ = addElement($1, $3, -1);
                  }
                  | IDENTIFIER
                  {
                     /* add the new identifier to the list of identifiers */
                    exists_size++;
                     $$ = addElement(NULL, $1, -1);
                  }
;

=======================

exp: NUMBER      { $$ = create_expression ($1, IMMEDIATE); }
   | IDENTIFIER  {
                     int location = 0;
   
                     /* get the location of the symbol with the given ID */
                     /* instead of location = get_symbol_location(program, $1, 0); */


                     fprintf(stdout, "We have seen %d existential quantifiers \n", exists_size-1);

                      for (int i=0; i<exists_size-1; i++) {

                        fprintf(stdout, "quantifier %s is being compared to variable %s \n", exists[i].id, $1);

                         if (strcmp(exists[i].id, $1)){
                           location = get_symbol_location(program, $1, 0);
                         } else {
                          location = exists[i].index_reg;
                          fprintf(stdout, "quantifier %s has overridden the variable %s value \n", exists[i].id, $1 );
                          break;
                         }

                      }
                     
                     fprintf(stdout, "returned register location is %d \n", location);
                     /* return the register location of IDENTIFIER as
                      * a value for `exp' */
                     $$ = create_expression (location, REGISTER);

                     /* free the memory associated with the IDENTIFIER */
                     free($1);
   }
   | IDENTIFIER LSQUARE exp RSQUARE {
                     int reg;

                     /* new */

                     t_axe_variable* v = getVariable(program, $1);
                     
                     if (exists[0].id != NULL){

                       fprintf(stdout, "Now storing the array length for array %d in the current scope.\n", quantifier_cursor);
                       exists[quantifier_cursor].array_size = v->arraySize;
                       quantifier_cursor++;

                     }

                    /* end */

                     /* load the value IDENTIFIER[exp]
                      * into `arrayElement' */
                     reg = loadArrayElement(program, $1, $3);

                     /* create a new expression */
                     $$ = create_expression (reg, REGISTER);

                     /* free the memory associated with the IDENTIFIER */
                     free($1);
   }

   /* new */
   | EXISTS identifier_list {

     int q_list_len = getLength($2);
     t_list *q_list_last = getLastElement($2);
     fprintf(stdout, "identifier list size is %d \n", q_list_len);
     //fprintf(stdout, "the last variable is: %s \n", strdup(q_list_last->data));

     if (exists[0].id != NULL)
       notifyError(AXE_SYNTAX_ERROR);

     for (int i=0; i<q_list_len; i++) {

       t_list *q_list_current = getElementAt($2,i);
       exists[i].id = strdup(q_list_current->data);
       exists[i].index_reg = gen_load_immediate(program, 0);
       exists[i].array_size = 0;
       
      // fprintf(stdout, "doing it %s \n", exists[i].id);
     }  

     // exists[0].id = strdup($2);
     // exists[0].index_reg = gen_load_immediate(program, 0);
     // exists[0].array_size = 0;
     $1 = assignNewLabel(program);

   }
   LPAR exp RPAR {

     fprintf(stdout, "==== coming up the parsing tree, exists size is %d \n", exists_size);

     for (int i=0)
     // Increment the index
     gen_addi_instruction(program, exists[0].index_reg, exists[0].index_reg, 1);

     // Define conditions to stop iteration
     t_axe_expression is_exp_zero = handle_binary_comparison (program, $5, create_expression(0, IMMEDIATE), _EQ_);
     t_axe_expression is_visit_not_completed = handle_binary_comparison (program, create_expression(exists[0].index_reg, REGISTER), create_expression(exists[0].array_size, IMMEDIATE), _LT_);

     handle_bin_numeric_op(program, is_exp_zero, is_visit_not_completed, ANDB);
     // if (is_exp_zero AND is_visit_not_completed) then jump to $1
     // else exit
     gen_bne_instruction(program, $1, 0);
     
     // If is_exp_zero==0 then exp is true (hence, exists is satisfied)
    $$ = handle_binary_comparison(program, is_exp_zero, create_expression(0, IMMEDIATE), _EQ_);

    free(exists[0].id);
    exists[0].id = NULL;
    exists[0].index_reg = 0;
    exists[0].array_size = 0;
    free($2);
    exists_size = 1;
    quantifier_cursor = 1;
   }

   /* end */
